<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <!--<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>-->
    <title>sandbox5</title>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <style>
        :root {
            --ball-radius: 32px;
        }

        * {
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
        }


        div#output {
            color: black;
            background-color: lightgreen;
            padding: 5px;
            margin: 3px;
            width: 70%;
            min-height: 50px;
            border: 1px solid #ababab;
        }


        .rect {
            width: 480px;
            height: 480px;
            border: 5px none #000;
            /*background-color: skyblue;*/
        }

        .border-div {
            position: absolute;
            margin-left: 10px; /**/
            margin-top: 10px; /**/
            width: 1px;
            height: 1px;
            border: 0px none #000;
            background-color: #000;


        }

        .border-1-left {
            left: 0px;
            top: 0px;
            transform-origin: 0 top;
            /*transform: rotate(-30deg) scale(5, calc(480));*/
            transform: scale(5, calc(480));
        }

        .border-2-top {
            left: 0px;
            top: 0px;
            transform-origin: left 50%;
            transform: scale(calc(480), 5);
        }

        .border-3-right {
            left: 480px;
            top: 0px;
            transform-origin: 100% top;
            /*transform: rotate(-30deg) scale(5, calc(480));*/
            transform: scale(5, calc(480));
        }

        .border-4-bottom {
            left: 0px;
            top: 480px;
            transform-origin: left 50%;
            transform: scale(calc(480), 5);
        }


        img {
            border-radius: 50%;
            width: calc(var(--ball-radius) * 2);
            height: calc(var(--ball-radius) * 2);
        }
        #rb {
            padding-left: 50%;
            padding-top: 0px;
        }
        .rotating {
            animation: rotate 5s infinite linear;
        }
        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(359deg);
            }
        }

    </style>
</head>
<body style="postition: absolute;">
<div class="rect" id="rect">
    <div id="rb">
        <img src="r.jpg" class="rotating" />
    </div>
</div>
<div id="border-1-left" class="border-div border-1-left"></div>
<div id="border-2-top" class="border-div border-2-top "></div>
<div id="border-3-right" class="border-div border-3-right"></div>
<div id="border-4-bottom" class="border-div border-4-bottom"></div>

<div id="output"></div>

<script>
    'use strict';
    $(document).ready(function () {
        let alpha = toRad(72); // стартовый угол полёта мяча [0, 360), [0, 2*PI)
        let r = +(window.getComputedStyle($('img')[0]).width.split('px')[0]) / 2; //
        console.log('r=' + r + ' px');
        let sleepTimeout = 1000/100;
        let victory = 3; // примерный шаг движения мяча под углом ("скорость"), в пикселях
        let rectSizes = new Map;
        rectSizes.set('width', 480);
        rectSizes.set('height', 480);
        rectSizes.set('phi', 0); //rad
        rectSizes.set('x5', 0);
        rectSizes.set('y5', 480);
        rectSizes.set('l1', 480);

        function sleep (ms) { // TODO: Move to deps/js/common.js
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Из градусов в радианы
         */
        function toRad (deg) {
            return deg / 180 * Math.PI;
        }

        function fromRad (ra) {
            return Math.round((ra * 180 / Math.PI) * 10) / 10;
        }

        /**
         * Возвращает 0 или код стены, которой достиг мяч:
         *  1 - левая стена,
         *  2 - верхняя стена,
         *  3 - правая стена,
         *  4 - нижняя стена,
         *  5 - угол между стенами 4 и 1,
         *  6 - угол между стенами 1 и 2,
         *  7 - угол между стенами 2 и 3,
         *  8 - угол между стенами 3 и 4,
         *  -1 - заблокированное состояние
         *  -2 - ошибочное состояние
         */

        /**
         * rectSizes:
         * width - длинна верхней стены
         * height - высота параллелограмма
         * phi - угол скоса
         * x5 - координата угла 5
         * y5 - координата угла 5
         * l1 - длинна стены 1
         *
         */
        function checkBorder (x, y) {
            let nearBorders = [check1(x, y), check2(x, y), check3(x, y), check4(x, y)];
            let sum = nearBorders[0] + nearBorders[1] + nearBorders[2] + nearBorders[3];
            if (sum == 0) {
                return 0;
            }
            if (sum > 2) { // мяч заблокирован
                return -1;
            }
            if (sum = 1) { // мяч у стены
                return nearBorders.indexOf(1) + 1;
            } else {  // мяч в углу (у двух стен)
                if (nearBorders[3] == 1 && nearBorders[0] == 1) {
                    return 5;
                } else if (nearBorders[0] == 1 && nearBorders[1] == 1) {
                    return 6;
                } else if (nearBorders[1] == 1 && nearBorders[2] == 1) {
                    return 7;
                } else if (nearBorders[2] == 1 && nearBorders[3] == 1) {
                    return 8;
                } else {
                    return -2;
                }
            }
        }

        /**
         * Коснулись или вышли за стену 1
         * h = y1 = cos(phi)*x + sin(phi)*y  расстояние от мяча до прямой
         */
        function check1 (x, y) {
            let h = Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y;
            return ((h-0) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 2
         */
        function check2 (x, y) {
            return ((y-0) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 3
         * h = l1*cos(phi) - (cos(phi)*x + sin(phi)*y)  расстояние от мяча до прямой
         */
        function check3 (x, y) {
            //return (x>=(rectSizes.get('width')-r)) ? 1 : 0;
            let h = rectSizes.get('width')*Math.cos(rectSizes.get('phi')) - (Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y);
            return ((h-0) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 4
         */
        function check4 (x, y) {
            return (y>=(rectSizes.get('height')-r)) ? 1 : 0;
        }

        /**
         * Выходит ли координата центра мяча за границы квадрата
         */
        function isOut (x, y) {
            if (check1(x,y) == 1 || check2(x,y) == 1 || check3(x,y) == 1 || check4(x,y) == 1) {
                return true;
            } else {
                return false;
            }
        }

        function changeDirection (x, y, alpha, victory, whichBorder) { // можем менять здесь только угол alpha
            let x0 = x;
            let y0 = y;
            let alpha0 = alpha;
            if (whichBorder == 0 || whichBorder < 0 || whichBorder > 8) {
                return [x0, y0, alpha0];
            }

            if (whichBorder >= 5) { // если попали в угол квадрата
                return [x0, y0, alpha0+toRad(180)];
            }

            let alpha2 = 0;
            switch (whichBorder) {
                case 1: case 3:
                    alpha2 = - alpha0 + 2*rectSizes.get('phi');
                    //console.log('alpha0='+fromRad(alpha0));
                    //console.log('alpha2='+fromRad(alpha2));
                    break
                case 2: case 4:
                    alpha2 = -alpha0;
                    break
                default:
                    break
            }

            [x, y, alpha] = calcNext(x0, y0, alpha2, victory);
            if (isOut(x, y)) {
                alpha2 += toRad(180);
            }
            [x, y, alpha] = calcNext(x0, y0, alpha2, victory);

            if (x == x0 || y == y0 || isOut(x, y) || isOut(x0, y0)) { // значит угол был около 90, и нужно поворачивать на 180
                alpha2 = alpha0+toRad(180);
                [x, y, alpha2] = calcNext(x0, y0, alpha2, victory);
                [x, y, alpha] = calcNext(x, y, alpha2, victory);
            }

            return [x0, y0, alpha];
        }

        function calcNext (x, y, alpha, victory) {
            x += victory*Math.cos(alpha);
            y += victory*Math.sin(alpha);

            x = Math.round(x);
            y = Math.round(y);
            return [x, y, alpha];
        }

        function getVisualPos () {
            let rb = $('#rb')[0];
            let x = +(window.getComputedStyle(rb).paddingLeft.split('px')[0]) + r; // получаем координату x (из строки)
            let y = +(window.getComputedStyle(rb).paddingTop.split('px')[0]) + r; // получаем координату y (из строки)
            return [x, y];
        }

        function setVisualPos (x, y) {
            let rb = $('#rb')[0];
            $(rb).css('padding-left', ''+(x-r)+'px');
            $(rb).css('padding-top', ''+(y-r)+'px');
        }

        let traceDivs = [];
        async function createDiv(x0, y0){
            var div = document.createElement("div");
            div.classList.add('trace');
            div.style.position = "absolute";
            div.style.width = "1px";
            div.style.height = "1px";
            div.style.backgroundColor = "red";
            div.style.left = x0+"px";
            div.style.top = y0+"px";
            div.style.transform = "scale(1, 1)";
            
            traceDivs.push(div); // добавляем в конец списка traceDivs (а unshift бы добавил в начало списка)
            
            document.body.appendChild(div);
            
            while (traceDivs.length > 200) {
                document.body.removeChild(traceDivs.shift()); // 1) убираем из начала списка traceDivs один элемент  2) и убираем его из document.body
            }
        }

        async function move () { // асинхронная функция
            let [x, y] = getVisualPos();

            $('#output').html(''); // empty
            var outputData = '';
            outputData += '(x,y): ('+x+','+y+')' + '<br/>';
            outputData += 'r=' + r + ' px' + '<br/>';
            outputData += '∠α: '+fromRad(alpha) + '&#176' + '<br/>';
            outputData += 'Шаг victory: '+victory + ' px' + '<br/>';
            outputData += 'Sleep: '+sleepTimeout+' ms' + '<br/>';
            $('#output').html(outputData);

            let x0 = x;
            let y0 = y;
            [x, y, alpha] = calcNext(x, y, alpha, victory);

            let whichBorder = 0;
            if ((whichBorder = checkBorder(x, y)) > 0) {
                // if(whichBorder == 1){
                //     [x, y, alpha] = changeDirectionL1(x0, y0, alpha, victory, whichBorder);
                // }else {
                [x, y, alpha] = changeDirection(x0, y0, alpha, victory, whichBorder);
                [x, y, alpha] = [x, y, alpha%(2*Math.PI)];
                do {
                    [x, y, alpha] = calcNext(x, y, alpha, victory);
                    await sleep(sleepTimeout);
                    setVisualPos(x, y);
                } while (checkBorder(x, y) == whichBorder); // из-за округлений значений возможно "застревание" у стены, поэтому лучше несколько шагов вместо одного, если дальше определяется та же стена
            } else {
                await sleep(sleepTimeout); // await (синхронное ожидание вызова) применим только к Promise и async функциям
            }
            setVisualPos(x, y);

            createDiv(x0, y0);
        }

        async function main () {
            while (true) {
                await move();
            }
        }

        function getComputedPx (bElement, str) {
            return window.getComputedStyle(bElement)[str].split('px')[0];
        }

        function getComputedPleft (bElement) {
            return window.getComputedStyle(bElement).left.split('px')[0];
        }

        function getComputedPtop (bElement) {
            return window.getComputedStyle(bElement).top.split('px')[0];
        }

        function changeBorder(ort, direction){
            let b = $('#rect')[0];
            let xy = getComputedPx(b, ort);
            let newXY = Number(xy) + direction * 10;
            $(b).css(ort, newXY + 'px');
            rectSizes.set(ort, newXY);
            console.log('changeBorder');
        }

        function shiftBottom(direction)
        {
            let b = $('#border-4-bottom')[0];
            let bLeft = getComputedPleft(b);
            let newbLeft = Number(bLeft) + direction * 10;
            $(b).css('left', ''+ newbLeft +'px');

            let lHeight = rectSizes.get("height");
            let phi = -Math.atan(newbLeft / lHeight);
            let lLength = Math.round(Math.sqrt(newbLeft**2 + lHeight**2));
            let l = $('#border-1-left')[0];
            //console.log("rotate(" + phi + "rad) scale(5, " + lLength + ")");
            l.style.transform = "rotate(" + phi + "rad) scale(5, " + lLength + ")";

            let r = $('#border-3-right')[0];
            r.style.transform = "rotate(" + phi + "rad) scale(5, " + lLength + ")";


            //rectSizes.set('width', 480);
            //rectSizes.set('height', 480);
            rectSizes.set('phi', phi);
            //rectSizes.set('x5', 0);
            rectSizes.set('y5', lHeight);
            rectSizes.set('l1', lLength);

        }

        window.addEventListener("keydown", function(event){
            if(event.shiftKey) {
                switch (event.code) {
                    case "ArrowRight":
                        shiftBottom(1);
                        break
                    case "ArrowLeft":
                        shiftBottom(-1);
                        break
                    default:
                        break
                }
            }else {
                switch (event.code) {
                    case "ArrowDown":
                        changeBorder('height', 1);
                        break
                    case "ArrowUp":
                        changeBorder('height', -1);
                        break
                    case "ArrowRight":
                        changeBorder('width', 1);
                        break
                    case "ArrowLeft":
                        changeBorder('width', -1);
                        break
                    default:
                        break
                }
            }
        })

        window.addEventListener("click", function(event){
            let x = event.clientX;
            let y = event.clientY;
            let hLeft = Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y;
            console.log('hLeft=' + hLeft);

            let dif=rectSizes.get('width')*Math.cos(rectSizes.get('phi'));
            let hRight = rectSizes.get('width')*Math.cos(rectSizes.get('phi')) - (Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y);
            console.log('phi=' + fromRad(rectSizes.get('phi')));
            console.log('cos=' + Math.cos(rectSizes.get('phi')));
            console.log('width=' + rectSizes.get('width'));

            console.log('dif=' +dif);
            console.log('hRight=' + hRight);
        })


        main();
    });
</script>
</body>
</html>
