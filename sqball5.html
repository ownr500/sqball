<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <!--<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>-->
    <title>sqball 5</title>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <style>
        :root {
            --ball-radius: 32px;
        }

        * {
            padding: 0;
            margin: 0;
        }

        body {
            width: 100%;
            height: 100%;
        }


        div#output {
            color: black;
            background-color: lightgreen;
            padding: 5px;
            margin: 3px;
            width: 70%;
            min-height: 50px;
            border: 1px solid #ababab;
        }


        .rect {
            width: 70%;
            min-height: 480px;
            border: 5px none #000;
            /*background-color: skyblue;*/
            bottom: 5px;
            position: relative;
        }

        .border-div {
            position: absolute;
            margin-left: 10px; /**/
            margin-top: 10px; /**/
            width: 1px;
            height: 1px;
            border: 0px none #000;
            background-color: #000;


        }

        .border-1-left {
            left: 0px;
            top: 0px;
            transform-origin: 0 top;
            /*transform: rotate(-30deg) scale(5, calc(480));*/
            transform: scale(5, calc(480));
        }

        .border-2-top {
            left: 0px;
            top: 0px;
            transform-origin: left 50%;
            transform: scale(calc(480), 5);
        }

        .border-3-right {
            left: 480px;
            top: 0px;
            transform-origin: 100% top;
            /*transform: rotate(-30deg) scale(5, calc(480));*/
            transform: scale(5, calc(480));
        }

        .border-4-bottom {
            left: 0px;
            top: 480px;
            transform-origin: left 50%;
            transform: scale(calc(480), 5);
        }


        .rect div img.rotating {
            border-radius: 50%;
            width: calc(var(--ball-radius) * 2);
            height: calc(var(--ball-radius) * 2);
        }
        #rb {
            padding-left: 50%;
            padding-top: 0px;
        }
        .rotating {
            animation: rotate 5s infinite linear;
        }
        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(359deg);
            }
        }

    </style>
</head>
<body style="postition: absolute;">
<div class="rect" id="rect">
    <div id="rb">
        <img src="data/r.jpg" class="rotating" />
    </div>
</div>
<div id="border-1-left" class="border-div border-1-left"></div>
<div id="border-2-top" class="border-div border-2-top "></div>
<div id="border-3-right" class="border-div border-3-right"></div>
<div id="border-4-bottom" class="border-div border-4-bottom"></div>

<!--<div id="output"></div>-->

<script>
    'use strict';
    $(document).ready(function () {       
        function getComputedPx (bElement, str) {
            return window.getComputedStyle(bElement)[str].split('px')[0];
        }
        function genRandomFloatNumber () {
            return (Math.random() + 0.3); // near 0.3 .. 1.29999
        }
        
        let sqOptions = {
            "borderColor": 'none',
            "jobs": [ // Если значение не соответствует, то ничего не отображается. Иначе отображается первый подошедший вариант.
                {"maxYear": '2023', "onlyMonth": '10', "onlyHour": '19', "ttlMinutes": '15', "imgSrc": 'data/clippy.gif', },
                {"maxYear": '9999', "onlyWeekday": '3,5', "onlyHour": '20', "ttlMinutes": '5', "imgSrc": 'data/robo.gif', },
                {"onlyWeekday": '4', "onlyDay": '12', "ttlMinutes": '25', "imgSrc": 'data/gooddy.gif', },
                {"onlyMonth": '03', "onlyDay": '08', "onlyHour": '18,19,20', "ttlMinutes": '15', "imgSrc": 'data/flowers2.jpg', },
                {"date": '2022-10-30', "onlyHour": '16', "ttlMinutes": '30', "imgSrc": 'data/witchcraft.gif', },
            ],
            "jobsCommon": {"ip4OddMinute": true, "ip3OddHour": null}, // Если ip "w.x.y.z", то "y" ip3, "z" ip4, а совпадение четности ip4 с минутами регулирует ip4OddMinute.
        };
        
        let alpha = toRad(35); // стартовый угол полёта мяча [0, 360), [0, 2*PI)
        let r = +(getComputedPx($('img')[0], 'width')) / 2; //
        console.log('r=' + r + ' px');
        let sleepTimeout = 1000/100;
        let victory = 3; // примерный шаг движения мяча под углом ("скорость"), в пикселях
        let w = +(getComputedPx($('#rect')[0], 'width'));
        let h = +(getComputedPx($('#rect')[0], 'height'));
        
        $('.rect').css('width', ''+w+'px');
        $('.rect').css('height', ''+h+'px');
        drawBorders();
        
        console.log(w, h);
        
        function sleep (ms) { // TODO: Move to deps/js/common.js
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Из градусов в радианы
         */
        function toRad (deg) {
            return deg / 180 * Math.PI;
        }

        function fromRad (ra) {
            return Math.round((ra * 180 / Math.PI) * 10) / 10;
        }

        /**
         * rectSizes:
         * width - длинна верхней стены
         * height - высота параллелограмма
         * phi - угол скоса
         * x5 - координата угла 5
         * y5 - координата угла 5
         * l1 - длинна стены 1
         *
         */


        /**
         * Возвращает 0 или код стены, которой достиг мяч:
         *  1 - левая стена,
         *  2 - верхняя стена,
         *  3 - правая стена,
         *  4 - нижняя стена,
         *  5 - угол между стенами 4 и 1,
         *  6 - угол между стенами 1 и 2,
         *  7 - угол между стенами 2 и 3,
         *  8 - угол между стенами 3 и 4,
         *  -1 - заблокированное состояние
         *  -2 - ошибочное состояние
         */

        function checkBorder (x, y) {
            let nearBorders = [check1(x, y), check2(x, y), check3(x, y), check4(x, y)];
            let sum = nearBorders[0] + nearBorders[1] + nearBorders[2] + nearBorders[3];
            if (sum == 0) {
                return 0;
            }
            if (sum > 2) { // мяч заблокирован
                return -1;
            }
            if (sum = 1) { // мяч у стены
                return nearBorders.indexOf(1) + 1;
            } else {  // мяч в углу (у двух стен)
                if (nearBorders[3] == 1 && nearBorders[0] == 1) {
                    return 5;
                } else if (nearBorders[0] == 1 && nearBorders[1] == 1) {
                    return 6;
                } else if (nearBorders[1] == 1 && nearBorders[2] == 1) {
                    return 7;
                } else if (nearBorders[2] == 1 && nearBorders[3] == 1) {
                    return 8;
                } else {
                    return -2;
                }
            }
        }

        /**
         * Коснулись или вышли за стену 1
         * h = y1 = cos(phi)*x + sin(phi)*y  расстояние от мяча до прямой
         */
        function check1 (x, y) {
            let z = x; //Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y;
            return ((z-0) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 2
         */
        function check2 (x, y) {
            let z = y;
            return ((z-0) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 3
         * h = l1*cos(phi) - (cos(phi)*x + sin(phi)*y)  расстояние от мяча до прямой
         */
        function check3 (x, y) {
            //return (x>=(rectSizes.get('width')-r)) ? 1 : 0;
            let z = x; //rectSizes.get('width')*Math.cos(rectSizes.get('phi')) - (Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y);
            return ((w-z) <= r) ? 1 : 0;
        }

        /**
         * Коснулись или вышли за стену 4
         */
        function check4 (x, y) {
            ///return (y>=(rectSizes.get('height')-r)) ? 1 : 0;
            let z = y;
            return ((h-z) <= r) ? 1 : 0;
        }

        /**
         * Выходит ли координата центра мяча за границы квадрата
         */
        function isOut (x, y) {
            if (check1(x,y) == 1 || check2(x,y) == 1 || check3(x,y) == 1 || check4(x,y) == 1) {
                return true;
            } else {
                return false;
            }
        }

        function changeDirection (x, y, alpha, victory, whichBorder) { // можем менять здесь только угол alpha
            let x0 = x;
            let y0 = y;
            let alpha0 = alpha;
            if (whichBorder == 0 || whichBorder < 0 || whichBorder > 8) {
                return [x0, y0, alpha0];
            }

            if (whichBorder >= 5) { // если попали в угол квадрата
                return [x0, y0, alpha0+toRad(180)];
            }

            let smallRandomPhi = genRandomFloatNumber()*4;
            let alpha2 = 0;
            switch (whichBorder) {
                case 1: case 3:
                    alpha2 = - alpha0 + 2*toRad(smallRandomPhi); /////+ 2*rectSizes.get('phi');
                    //console.log('alpha0='+fromRad(alpha0));
                    //console.log('alpha2='+fromRad(alpha2));
                    break
                case 2: case 4:
                    alpha2 = -alpha0;
                    break
                default:
                    break
            }

            [x, y, alpha] = calcNext(x0, y0, alpha2, victory);
            if (isOut(x, y)) {
                alpha2 += toRad(180);
            }
            [x, y, alpha] = calcNext(x0, y0, alpha2, victory);

            if (x == x0 || y == y0 || isOut(x, y) || isOut(x0, y0)) { // значит угол был около 90, и нужно поворачивать на 180
                alpha2 = alpha0+toRad(180);
                [x, y, alpha2] = calcNext(x0, y0, alpha2, victory);
                [x, y, alpha] = calcNext(x, y, alpha2, victory);
            }

            return [x0, y0, alpha];
        }

        function calcNext (x, y, alpha, victory) {
            x += victory*Math.cos(alpha);
            y += victory*Math.sin(alpha);

            x = Math.round(x);
            y = Math.round(y);
            return [x, y, alpha];
        }

        function getVisualPos () {
            let rb = $('#rb')[0];
            let x = +(getComputedPx(rb, 'paddingLeft')) + r; // получаем координату x (из строки)
            let y = +(getComputedPx(rb, 'paddingTop')) + r; // получаем координату y (из строки)
            return [x, y];
        }

        function setVisualPos (x, y) {
            let rb = $('#rb')[0];
            $(rb).css('padding-left', ''+(x-r)+'px');
            $(rb).css('padding-top', ''+(y-r)+'px');
            
            drawBorders();
        }
        
        function drawBorders () {
            $('.border-1-left').css({
                "transform-origin": '0 top',
                "transform": 'scale(5, calc('+h+'))',
            });            
            $('.border-2-top').css({
                "transform-origin": 'left 50%',
                "transform": 'scale(calc('+w+'), 5)',
            });
            $('.border-3-right').css({
                "transform-origin": '100% top',
                "transform": 'scale(5, calc('+h+'))',
                "left": ''+w+'px',
                "top": '0px',
            });
            $('.border-4-bottom').css({
                "transform-origin": 'left 50%',
                "transform": 'scale(calc('+w+'), 5)',
                "left": '0px',
                "top": ''+h+'px',
            });
            
            if ((!sqOptions.borderColor && sqOptions.borderColor !== undefined) || sqOptions.borderColor == 'none') {
                $('.border-div').css('display', 'none');
            } else {
                $('.border-div').css('border', '0px none '+sqOptions.borderColor);
                $('.border-div').css('background-color', ''+sqOptions.borderColor);
            }
        }

        let traceDivs = [];
        async function createDiv(x0, y0){
            var div = document.createElement("div");
            div.classList.add('trace');
            div.style.position = "absolute";
            div.style.width = "1px";
            div.style.height = "1px";
            div.style.backgroundColor = "red";
            div.style.left = x0+"px";
            div.style.top = y0+"px";
            div.style.transform = "scale(1, 1)";
            
            traceDivs.push(div); // добавляем в конец списка traceDivs (а unshift бы добавил в начало списка)
            
            document.body.appendChild(div);
            
            while (traceDivs.length > 200) {
                document.body.removeChild(traceDivs.shift()); // 1) убираем из начала списка traceDivs один элемент  2) и убираем его из document.body
            }
        }

        async function move () { // асинхронная функция
            let [x, y] = getVisualPos();

            $('#output').html(''); // empty
            var outputData = '';
            outputData += '(x,y): ('+x+','+y+')' + '<br/>';
            outputData += 'r=' + r + ' px' + '<br/>';
            outputData += '∠α: '+fromRad(alpha) + '&#176' + '<br/>';
            outputData += 'Шаг victory: '+victory + ' px' + '<br/>';
            outputData += 'Sleep: '+sleepTimeout+' ms' + '<br/>';
            $('#output').html(outputData);

            let x0 = x;
            let y0 = y;
            [x, y, alpha] = calcNext(x, y, alpha, victory);

            let whichBorder = 0;
            if ((whichBorder = checkBorder(x, y)) > 0) {
                // if(whichBorder == 1){
                //     [x, y, alpha] = changeDirectionL1(x0, y0, alpha, victory, whichBorder);
                // }else {
                [x, y, alpha] = changeDirection(x0, y0, alpha, victory, whichBorder);
                [x, y, alpha] = [x, y, alpha%(2*Math.PI)];
                do {
                    [x, y, alpha] = calcNext(x, y, alpha, victory);
                    await sleep(sleepTimeout);
                    setVisualPos(x, y);
                } while (checkBorder(x, y) == whichBorder); // из-за округлений значений возможно "застревание" у стены, поэтому лучше несколько шагов вместо одного, если дальше определяется та же стена
            } else {
                await sleep(sleepTimeout); // await (синхронное ожидание вызова) применим только к Promise и async функциям
            }
            setVisualPos(x, y);

            createDiv(x0, y0);
        }

        async function subMain () {
            let k = 1000;
            while (k > 0) {
                await move();
                --k;
            }
        }
        
        async function main () {
            while (true) {
                for (let state of sqOptions.jobs) {
                    if (!state.imgSrc) {
                        continue;
                    }
                    $('div#rb>img').attr('src', ''+state.imgSrc);
                    await subMain();
                }
            }
        }

//        function changeBorder(ort, direction){
//            let b = $('#rect')[0];
//            let xy = getComputedPx(b, ort);
//            let newXY = Number(xy) + direction * 10;
//            $(b).css(ort, newXY + 'px');
//            rectSizes.set(ort, newXY);
//            console.log('changeBorder');
//        }

        function shiftBottom(direction)
        {
            let b = $('#border-4-bottom')[0];
            let bLeft = getComputedPx(b, 'left');
            let newbLeft = Number(bLeft) + direction * 10;
            $(b).css('left', ''+ newbLeft +'px');

            let lHeight = +(getComputedPx($('.border-4-bottom')[0], 'top')); ///rectSizes.get("height");
            let phi = -Math.atan(newbLeft / lHeight);
            let lLength = Math.round(Math.sqrt(newbLeft**2 + lHeight**2));
            let l = $('#border-1-left')[0];
            //console.log("rotate(" + phi + "rad) scale(5, " + lLength + ")");
            l.style.transform = "rotate(" + phi + "rad) scale(5, " + lLength + ")";

            let r = $('#border-3-right')[0];
            r.style.transform = "rotate(" + phi + "rad) scale(5, " + lLength + ")";


//            rectSizes.set('phi', phi);
//            rectSizes.set('y5', lHeight);
//            rectSizes.set('l1', lLength);

        }

        /*window.addEventListener("keydown", function (event) {
            if (event.shiftKey) {
                switch (event.code) {
                    case "ArrowRight":
                        shiftBottom(1);
                        break
                    case "ArrowLeft":
                        shiftBottom(-1);
                        break
                    default:
                        break
                }
            } else {
                switch (event.code) {
                    case "ArrowDown":
                        changeBorder('height', 1);
                        break
                    case "ArrowUp":
                        changeBorder('height', -1);
                        break
                    case "ArrowRight":
                        changeBorder('width', 1);
                        break
                    case "ArrowLeft":
                        changeBorder('width', -1);
                        break
                    default:
                        break
                }
            }
        });*/

//        window.addEventListener("click", function(event){
//            let x = event.clientX;
//            let y = event.clientY;
//            let hLeft = Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y;
//            console.log('hLeft=' + hLeft);
//
//            let dif=rectSizes.get('width')*Math.cos(rectSizes.get('phi'));
//            let hRight = rectSizes.get('width')*Math.cos(rectSizes.get('phi')) - (Math.cos(rectSizes.get('phi')) * x + Math.sin(rectSizes.get('phi')) * y);
//            console.log('phi=' + fromRad(rectSizes.get('phi')));
//            console.log('cos=' + Math.cos(rectSizes.get('phi')));
//            console.log('width=' + rectSizes.get('width'));
//
//            console.log('dif=' +dif);
//            console.log('hRight=' + hRight);
//        })


        main();
    });
</script>
</body>
</html>
